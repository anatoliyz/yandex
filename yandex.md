- Для обмена данных с сервером предпочтительно использовать формат JSON.Для преобразования между форматами можно использовать NPM пакет xml2js:https://www.npmjs.com/package/xml2js- В реакт приложении эти данные предпочтительно хранить в Redux Store:```JavaScript> JSON.parse(localStorage.redux.editor.tree)```- Загрузка данных и обработка ошибок:```JavaScript// @flowimport {AxiosInstance} from 'axios';import {HttpException} from 'node-exceptions';export default class Service {    httpClient: AxiosInstance;    constructor(httpClient: AxiosInstance, idToken: string)    {        this.httpClient = httpClient;        this.httpClient.defaults.headers['Authorization'] = `Bearer ${idToken}`;        this.httpClient.interceptors.response.use(            ({data: response}) => response !== undefined                ? response : Promise.reject(new HttpException('Malformed response!')),            (error: {response?: {status: string}}) => {                if (!error.response) {                    return Promise.reject(new HttpException('Unknown error'));                }                if (error.response.status === 401) {                    return Promise.reject(new HttpException('Authorization Error!'));                }                                //...                                return Promise.reject(error);            }        );    };}```**service.js**```JavaScript// @flowimport ...export default class XmlService extends Service {    getRawXml(fileName: string): Promise<any> {        return this.httpClient.get('/xml', {params: {fileName}})    }```- Обновление данных предпочтительно реализовать в React thunks:**thunk.js**```JavaScript// @flowimport ...export type Tree<T> =         | { type: "Node", value: T, children: Tree<T>[], }       | { type: "EmptyTree" }export type XmlNode = {    name: string,    isTextNode: boolean,    // поле для сохранения состояния: свернуто/развернуто    isCollapsed: boolean,    // значение CDATA, может быть undefined    textValue?: string,       // ...}const buildXmlTree = (obj, tree) => {    for (let property in obj) {        if (obj.hasOwnProperty(property)) {            if (!tree.children) { tree.children = [] }                        if (typeof obj[property] == "object") {                let lastIndex = tree.children.push({					name: property,					isCollapsed: false,					//...				}) - 1;                buildXmlTree(obj[property], tree.children[lastIndex]);            } else {                tree.children.push({                    name: property,                    isCollapsed: false,                    children: [{                        name: 'CDATA',                        isTextNode: true,                        value: obj[property]						//...                    }]                })            }        }    }}export const getXmlContentAndSetInStore = (fileName: string) =>    async (dispatch: Function, getState: Function, {xmlService}: {xmlService: XmlService}): Promise<void> => {        try {            let rawXml = await xmlService.getRawXml(fileName);            let result: Tree<XmlNode> = {};            // здесь вызываем метод который рекурсивно обходит JSON Object			// возвращаемый службой и преобразуем его в XmlTree						buildXmlTree(rawXml, result);            dispatch(setParsedXmlContent(result));            console.log('XmlData in store updated.')        } catch (error) {            dispatch(getXmlContentAndSetInStoreError(error));            dispatch('Error updating XmlData in store!')        }};```**reducer.js**```JavaScript// @flowimport ...export const GET__XML__CONTENT__ERROR = 'GET__XML__CONTENT__ERROR';export const SET__XML__CONTENT = 'SET__XML__CONTENT';type State = {    +tree: Tree<XmlNode>    //...};const defaultState: State = {    tree: undefined,    //...};export const xmlEditor = (state: State = defaultState, action: any) => {    switch (action.type) {        case SET__XML__CONTENT:            return Object.assign({}, state, {tree: action.result});        default:            return state    }};```**actions.js**```JavaScript// @flowimport ...export const setParsedXmlContent = (result: Tree<XmlNode>) => ({   type: SET__XML__CONTENT, result});export const getXmlContentAndSetInStoreError = (message: string) => ({    type: GET__XML__CONTENT__ERROR, message});```